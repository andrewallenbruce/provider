---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# `provider` <img src="man/figures/logo.svg" align="right" height="300" />

<!-- badges: start -->
[![R-CMD-check](https://github.com/andrewallenbruce/provider/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/andrewallenbruce/provider/actions/workflows/R-CMD-check.yaml)
[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![Project Status: WIP - Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)
[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://choosealicense.com/licenses/mit/)
[![code size](https://img.shields.io/github/languages/code-size/andrewallenbruce/provider.svg)](https://github.com/andrewallenbruce/provider)
[![last commit](https://img.shields.io/github/last-commit/andrewallenbruce/provider.svg)](https://github.com/andrewallenbruce/provider/commits/main)
<!-- badges: end -->

The goal of `provider` is to provide performant and reliable open-source tools to facilitate easy access to [healthcare provider](https://en.wikipedia.org/wiki/Health_care_provider) data through publicly available APIs & sources. The current list of supported APIs are:

<br>

 -  [NPPES National Provider Identifier (NPI) Registry API](https://npiregistry.cms.hhs.gov/search)
 -  [Medicare Fee-For-Service Public Provider Enrollment API](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/medicare-fee-for-service-public-provider-enrollment)
 -  [Medicare Order and Referring API](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/medicare-fee-for-service-public-provider-enrollment)
 -  [Medicare Provider and Supplier Taxonomy Crosswalk](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/medicare-provider-and-supplier-taxonomy-crosswalk)
 -  [Medicare Physician & Other Practitioners - by Provider and Service API](https://data.cms.gov/provider-summary-by-type-of-service/medicare-physician-other-practitioners/medicare-physician-other-practitioners-by-provider-and-service)
 -  [Medicare Revalidation Due Date API](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/revalidation-due-date-list)
 -  [Medicare Revalidation Clinic Group Practice Reassignment API](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/revalidation-clinic-group-practice-reassignment)
 -  [Medicare Opt Out Affidavits API](https://data.cms.gov/provider-characteristics/medicare-provider-supplier-enrollment/opt-out-affidavits)
 -  [CMS Public Reporting of Missing Digital Contact Information API](https://data.cms.gov/provider-compliance/public-reporting-of-missing-digital-contact-information)
 
<br>

## Installation

You can install the development version of `provider` from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("andrewallenbruce/provider")

# install.packages("remotes")
remotes::install_github("andrewallenbruce/provider")
```
<br>

<br>

## Motivating Example

Let's say that you're billing claims for a healthcare provider and you get a denial for incorrect primary taxonomy code. Armed with the provider's NPI, you can search the **NPPES NPI Registry API** with the `prov_npi_nppes()` function & unpack the results with the `prov_nppes_unpack()` function:

<br>

```{r warning=FALSE}
# Load library
library(provider)

# Query the NPPES API
provider_nppes <- prov_npi_nppes(1003026055) |> 
                  prov_nppes_unpack()
```

<br>

As it turns out, `207R00000X` is her secondary taxonomy and `207RE0101X` should be entered on the claim:

<br>

```{r echo=FALSE}
provider_nppes |> 
  dplyr::select("NPI" = npi, 
                "Last Name" = last_name,
                "Provider Type" = prov_type, 
                "Code" = taxon_code, 
                "Primary" = taxon_primary, 
                "Description" = taxon_desc, 
                "State" = taxon_state, 
                "License" = taxon_license) |> 
  knitr::kable()
```

<br>

What if you need the provider's PECOS PAC ID or their Enrollment ID? Using the `prov_mcr_ffs()` function, you can search Medicare's **Fee-For-Service Public Provider Enrollment API**:

<br>

```{r}
provider_ffs <- prov_mcr_ffs(1003026055)
```

<br>

```{r echo=FALSE}
provider_ffs |> dplyr::select(
                NPI, 
                "Last Name" = LAST_NAME,
                "PECOS PAC ID" = PECOS_ASCT_CNTL_ID, 
                "PECOS Enrollment ID" = ENRLMT_ID, 
                "Provider Type" = PROVIDER_TYPE_DESC, 
                "State" = STATE_CD) |> 
                knitr::kable()
```

<br>

Is the provider currently eligible to make referrals to Medicare Part B or a Home Health Agency (HHA)? Order Durable Medical Equipment (DME) or Power Mobility Devices (PMDs)? Search Medicare's **Order and Referring API** with `prov_mcr_ordref()`:

<br>

```{r}
provider_oar <- prov_mcr_ordref(1003026055)
```

<br>

```{r echo=FALSE}
provider_oar |> dplyr::select(
                NPI, 
                "Last Name" = LAST_NAME,
                "First Name" = FIRST_NAME, 
                "Part B" = PARTB, 
                DME, HHA, PMD) |> 
                knitr::kable()
```

<br>

You may need to find Medicare's specialty codes for this provider's taxonomies. Using the output from the NPPES search in the first example, you can search Medicare's **Provider and Supplier Taxonomy Crosswalk API** with `prov_mcr_taxcross()`:

<br>

```{r}
provider_cross <- provider_nppes |> dplyr::distinct(taxon_code) |> 
                  dplyr::group_split(taxon_code) |> 
                  purrr::map_dfr(prov_mcr_taxcross)
```

<br>

```{r echo=FALSE}
provider_cross |> 
  janitor::clean_names() |> 
  dplyr::select("Taxonomy Code" = provider_taxonomy_code, 
                "Medicare Specialty Code" = medicare_specialty_code,
                "Provider Type" = medicare_provider_supplier_type_description, 
                "Taxonomy Class" = provider_taxonomy_description_type_classification_specialization) |> 
                knitr::kable()
```

<br>

You can check to see if a provider is due to revalidate their Medicare enrollment by accessing Medicare's **Revalidation Due Date API** with `prov_mcr_reval_date()`:

<br>

```{r}
provider_due <- prov_mcr_reval_date(1760485387)
```

<br>

```{r echo=FALSE}
provider_due |> 
  janitor::clean_names() |> 
  dplyr::select("NPI" = national_provider_identifier, 
                "Enrollment ID" = enrollment_id,
                "Enrollment Type" = enrollment_type,
                "Last Name" = last_name,
                "State" = enrollment_state_code,
                "Provider Type" = provider_type_text, 
                "Specialty" = enrollment_specialty,
                "Revalidation Due Date" = revalidation_due_date) |> 
                knitr::kable()
```

<br>

Providers may need to update their digital contact information in the NPPES system. To check, you can access the **CMS Public Reporting of Missing Digital Contact Information API** with `prov_nppes_missing()`:

<br>

```{r}
provider_miss <- prov_nppes_missing(1760485387)
```

<br>

```{r echo=FALSE}
provider_miss |> knitr::kable()
```
<br>

You can find out if a provider has opted out of Medicare by searching the **Medicare Opt Out Affidavits API** with `prov_opt_out()`:

<br>

```{r}
provider_opt_out <- prov_opt_out(1114974490)
```

<br>

```{r echo=FALSE}
provider_opt_out |> 
  janitor::clean_names() |> 
  dplyr::select(
    NPI = npi,
    optout_effective_date,
    optout_end_date,
    Updated = last_updated,
    Last = last_name,
    First = first_name,
    Specialty = specialty,
    Address = first_line_street_address,
    City = city_name,
    State = state_code,
    "Eligible to Order & Refer" = eligible_to_order_and_refer) |>
  dplyr::mutate(optout_effective_date = datefixR::fix_date_char(optout_effective_date, format = "mdy"),
                optout_end_date = datefixR::fix_date_char(optout_end_date, format = "mdy"),
                Updated = datefixR::fix_date_char(Updated, format = "mdy")) |> 
  dplyr::rename("Optout Effective" = optout_effective_date, "Optout End" = optout_end_date) |> 
  knitr::kable()
```



<br>

Using `prov_mcr_phys_pract()`, you can access **Medicare's Physician & Other Practitioners - by Provider and Service API**:

<br>

```{r}
provider_2020 <- prov_mcr_phys_pract(npi = 1003026055, 
                                     year = "2020")
```

<br>

```{r echo=FALSE}
provider_2020 |>
  janitor::clean_names() |> 
  dplyr::select(Year = year,
                NPI = rndrng_npi,
                "Last Name" = rndrng_prvdr_last_org_name,
                City = rndrng_prvdr_city,
                State = rndrng_prvdr_state_abrvtn,
                PAR = rndrng_prvdr_mdcr_prtcptg_ind,
                HCPCS = hcpcs_cd,
                "Benefits" = tot_benes,
                "Services" = tot_srvcs,
                "Avg Billed" = avg_sbmtd_chrg,
                "Avg Allowed" = avg_mdcr_alowd_amt,
                "Avg Payment" = avg_mdcr_pymt_amt) |> 
  knitr::kable()
```
<br>

This API contains data going back to 2013, so you can perform a long-term analysis of a provider's Medicare data:

<br>

```{r}
# Retrieve the data from each year
pr2020 <- prov_mcr_phys_pract(1003026055, "2020")
pr2019 <- prov_mcr_phys_pract(1003026055, "2019")
pr2018 <- prov_mcr_phys_pract(1003026055, "2018")
pr2017 <- prov_mcr_phys_pract(1003026055, "2017")
pr2016 <- prov_mcr_phys_pract(1003026055, "2016")
pr2015 <- prov_mcr_phys_pract(1003026055, "2015")
pr2014 <- prov_mcr_phys_pract(1003026055, "2014")
pr2013 <- prov_mcr_phys_pract(1003026055, "2013")

# Bind the data frames together by row
prov_2013_2020 <- dplyr::bind_rows(pr2020, 
                                   pr2019, 
                                   pr2018, 
                                   pr2017, 
                                   pr2016, 
                                   pr2015, 
                                   pr2014, 
                                   pr2013)
```

<br>

```{r echo=FALSE, message=FALSE, warning=FALSE}
prov_2013_2020 |> 
  janitor::clean_names() |> 
  dplyr::group_by(hcpcs_cd, hcpcs_desc) |> 
  dplyr::summarise(
    Benefits = sum(tot_benes),
    Services = sum(tot_srvcs),
    Avg_Billed = janitor::round_half_up(mean(avg_sbmtd_chrg), digits = 2),
    Avg_Allowed = janitor::round_half_up(mean(avg_mdcr_alowd_amt), digits = 2),
    Avg_Payment = janitor::round_half_up(mean(avg_mdcr_pymt_amt), digits = 2)) |> 
  dplyr::ungroup() |> 
  dplyr::rename(HCPCS = hcpcs_cd, 
                "HCPCS Description" = hcpcs_desc,
                "Avg Charge" = Avg_Billed,
                "Avg Allowed" = Avg_Allowed,
                "Avg Payment" = Avg_Payment
                ) |> 
  #dplyr::arrange(dplyr::desc(Avg_Payment)) |> 
  knitr::kable()
```

<br>

<details>

<summary>Click for Table Code</summary>

``` r
gt_table <- prov_2013_2020 |>
  janitor::clean_names() |> 
  dplyr::select(year,
                hcpcs = hcpcs_cd,
                benefits = tot_benes,
                services = tot_srvcs,
                avg_bill = avg_sbmtd_chrg,
                avg_allow = avg_mdcr_alowd_amt,
                avg_pay = avg_mdcr_pymt_amt) |> 
  dplyr::filter(hcpcs != "82044",
                hcpcs != "82947",
                hcpcs != "83037",
                hcpcs != "83970",
                hcpcs != "84100",
                hcpcs != "95251",
                hcpcs != "99203",
                hcpcs != "99222") |> 
  dplyr::group_by(hcpcs) |> 
  dplyr::summarize(
    ben_sum = sum(benefits),
    ben_mean = mean(benefits),
    ben_med = median(benefits),
    ben_spark = list(benefits),
    serv_sum = sum(services),
    serv_mean = mean(services),
    serv_med = median(services),
    serv_spark = list(services),
    char_mean = mean(avg_bill),
    char_med = median(avg_bill),
    char_spark = list(avg_bill),
    all_mean = mean(avg_allow),
    all_med = median(avg_allow),
    all_spark = list(avg_allow),
    pay_mean = mean(avg_pay),
    pay_med = median(avg_pay),
    pay_spark = list(avg_pay),
    .groups = "drop")

gt_table <- gt_table |> 
  gt::gt(groupname_col = "hcpcs") |> 
  gt::tab_header(title = gt::md("**Provider's Medicare Data Summary**: 2013 - 2020"), 
                 subtitle = gt::md("Codes with a Beneficiary count *less than 40* have been excluded.")) |> 
  gtExtras::gt_theme_nytimes() |> 
  gt::tab_options(row_group.as_column = TRUE, footnotes.multiline = TRUE) |> 
  gtExtras::gt_plt_sparkline(ben_spark, type = "ref_iqr", fig_dim = c(5, 30), same_limit = FALSE, palette = c("black", "black", "blue", "green", "red")) |> 
  gtExtras::gt_plt_sparkline(serv_spark, type = "ref_iqr", fig_dim = c(5, 30), same_limit = FALSE, palette = c("black", "black", "blue", "green", "red")) |> 
  gtExtras::gt_plt_sparkline(char_spark, type = "ref_iqr", fig_dim = c(5, 30), same_limit = FALSE, palette = c("black", "black", "blue", "green", "red")) |> 
  gtExtras::gt_plt_sparkline(all_spark, type = "ref_iqr", fig_dim = c(5, 30), same_limit = FALSE, palette = c("black", "black", "blue", "green", "red")) |> 
  gtExtras::gt_plt_sparkline(pay_spark, type = "ref_iqr", fig_dim = c(5, 30), same_limit = FALSE, palette = c("black", "black", "blue", "green", "red")) |> 
  gtExtras::gt_add_divider(columns = c("hcpcs", "ben_spark", "serv_spark", 
                                       "char_spark", "all_spark", "pay_spark"), 
                           style = "dotted", color = "gray") |> 
  gt::fmt_number(columns = c(ben_mean:ben_med, serv_mean:serv_med), decimals = 0) |> 
  gt::fmt_currency(columns = c(char_mean:char_med, all_mean:all_med, pay_mean:pay_med), currency = "USD") |> 
  gt::tab_spanner(label = "Beneficiaries", id = "ben", columns = c(ben_sum, ben_mean, ben_med, ben_spark)) |> 
  gt::tab_spanner(label = "Services", id = "serv", columns = c(serv_sum, serv_mean, serv_med, serv_spark)) |> 
  gt::tab_spanner(label = "Submitted Charge", columns = c(char_mean, char_med, char_spark)) |> 
  gt::tab_spanner(label = "Allowed Amount", columns = c(all_mean, all_med, all_spark)) |> 
  gt::tab_spanner(label = "Payment", columns = c(pay_mean, pay_med, pay_spark)) |> 
  gt::cols_label(ben_sum = "Count", ben_mean = "Mean", ben_med = "Median", ben_spark = "Trend") |> 
  gt::cols_label(serv_sum = "Count", serv_mean = "Mean", serv_med = "Median", serv_spark = "Trend") |> 
  gt::cols_label(char_mean = "Mean", char_med = "Median", char_spark = "Trend") |> 
  gt::cols_label(all_mean = "Mean", all_med = "Median", all_spark = "Trend") |> 
  gt::cols_label(pay_mean = "Mean", pay_med = "Median", pay_spark = "Trend") |> 
  gt::tab_source_note(source_note = gt::md("Data Source: *Physician & Other Practitioners: by Provider and Service* (2013 - 2020). **Medicare.**")) |> 
  gt::tab_footnote(footnote = gt::md("Number of *distinct* Medicare beneficiaries receiving the service for each HCPCS code."), 
                   locations = gt::cells_column_spanners(spanners = "ben")) |> 
  gt::tab_footnote(footnote = gt::md("Number of services provided. *Note: The metrics used to count the number provided can vary from service to service.*"), 
                   locations = gt::cells_column_spanners(spanners = "serv")) |> 
  gt::opt_table_outline() |> 
  gt::opt_stylize(style = 1, color = "red", add_row_striping = TRUE) |> 
  gtExtras::gt_color_rows(ben_sum) |> 
  gtExtras::gt_color_rows(serv_sum) |> 
  gtExtras::gt_color_rows(char_mean) |> 
  gtExtras::gt_color_rows(all_mean) |> 
  gtExtras::gt_color_rows(pay_mean)

gt_table |> gt::gtsave("gt_provider.png", expand = 20, zoom = 2, vwidth = 1500)
```
</details>

<br>

![](man/figures/gt_provider.png){width="100%"}

<br>
<br>

## Code of Conduct

Please note that the provider project is released with a [Contributor Code of Conduct](https://andrewallenbruce.github.io/provider/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
