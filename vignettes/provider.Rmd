---
title: "Overview of Provider"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of Provider}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "#>",
  dpi       = 300, 
  out.width = "100%",
  fig.path  = "man/figures/README-"
)
```

```{r pkgload}
library(provider)
```

<br>

## NPPES NPI Public Registry API

<br>

You're billing for a healthcare provider and receive a `CO-8` denial on a claim and you need to confirm whether or not the correct taxonomy code was entered on the claim. Armed with the provider's NPI, you can search the **NPPES NPI Registry API** with the `provider_nppes()` function:

<br>

```{r warning=FALSE}
# Load library
library(provider)

# Query the NPPES API
nppes_ex <- provider_nppes(npi = 1760485387)
```

<br>

```{r echo=FALSE}
nppes_ex
```

<br>

Unpack the API response with the `provider_unpack()` function:

<br>

```{r}
nppes_ex <- provider_unpack(nppes_ex)
```

<br>

Giving you the results in tibble form:

<br>

```{r}
nppes_ex |> 
  tidyr::nest(identifiers = c(ident_code, 
                              ident_desc, 
                              ident_issuer, 
                              identifier, 
                              ident_state),
              taxonomies = c(taxon_code, 
                             taxonomy_group, 
                             taxon_desc, 
                             taxon_state, 
                             taxon_license, 
                             taxon_primary),
              addresses = c(country_code, 
                            address_purpose, 
                            address_1, 
                            city, 
                            state, 
                            postal_code, 
                            telephone_number, 
                            fax_number))
```


<br>

## Medicare Fee-For-Service Public Provider Enrollment API

<br> 

What if you need the provider's PECOS PAC ID or Enrollment ID? Using the `provider_mppe()` function, you can search Medicare's **Fee-For-Service Public Provider Enrollment API**:

<br>

```{r}
provider_enrollment(npi = 1760485387)
```

<br>

## Medicare Order and Referring API

<br>

Is the provider currently eligible to make referrals to Medicare Part B or a Home Health Agency (HHA)? Order Durable Medical Equipment (DME) or Power Mobility Devices (PMDs)? Search Medicare's **Order and Referring API** with `provider_moar()`:

<br>

```{r}
order_refer(npi = 1760485387)
```

<br>

## Medicare Provider and Supplier Taxonomy Crosswalk API

<br>

You may need to find Medicare's specialty codes for this provider's taxonomies. Using the output from the NPPES search in the first example, you can search Medicare's **Provider and Supplier Taxonomy Crosswalk API** with `provider_mpstc()`:

<br>

```{r}
taxonomy_crosswalk(taxonomy_code = "2086S0102X")
```



<br>

You can check to see if a provider is due to revalidate their Medicare enrollment by accessing Medicare's **Revalidation Due Date API** with `provider_mrdd()`:

<br>

```{r}
revalidation_date(npi = 1760485387)
```

<br>

Providers may need to update their digital contact information in the NPPES system. To check, you can access the **CMS Public Reporting of Missing Digital Contact Information API** with `provider_promdci()`. If they appear in the search results, it's time to update their NPPES contact information:

<br>

```{r}
missing_information(npi = 1760485387)
```

<br>

You can find out if a provider has opted out of Medicare by searching the **Medicare Opt Out Affidavits API** with `provider_mooa()`:

<br>

```{r}
opt_out(npi = 1114974490)
```

<br>

Using `provider_mpop()`, you can access **Medicare's Physician & Other Practitioners - by Provider and Service API**:

<br>

```{r}
physician_by_service(npi = 1760485387, year = "2020")
```


<br>

This API contains data going back to 2013, so you can perform a long-term analysis of a provider's Medicare data:

<br>

```{r}
purrr::map_dfr(as.character(2013:2020), ~physician_by_service(npi = 1003000126, year = .x)) |> 
  dplyr::group_by(hcpcs_cd, hcpcs_desc) |> 
  dplyr::summarise(
    Benefits = sum(tot_benes),
    Services = sum(tot_srvcs),
    Avg_Billed = janitor::round_half_up(mean(avg_sbmtd_chrg), digits = 2),
    Avg_Allowed = janitor::round_half_up(mean(avg_mdcr_alowd_amt), digits = 2),
    Avg_Payment = janitor::round_half_up(mean(avg_mdcr_pymt_amt), digits = 2)) |> 
  dplyr::ungroup() |> 
  dplyr::rename(HCPCS = hcpcs_cd, 
                "HCPCS Description" = hcpcs_desc,
                "Avg Charge" = Avg_Billed,
                "Avg Allowed" = Avg_Allowed,
                "Avg Payment" = Avg_Payment) |> 
  dplyr::arrange(dplyr::desc(Services)) |> 
  knitr::kable()
```



Using packages like {gt} & {ggplot2}, you can create tables and graphs for reporting purposes:

<br>

<details>

<summary>Click for Table Code</summary>


```{r echo=FALSE, eval=FALSE, include=FALSE}
# First row of data
mpop_ex_2020_row1 <- mpop_ex_2020 |> dplyr::filter(dplyr::row_number() %in% 1)

# First, last, credentials
mpop_ex_name_cred <- stringr::str_c(
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_first_name, "both"), " ",
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_last_org_name, "both"), ", ",
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_crdntls, "both"))

# NPI
mpop_ex_npi <- stringr::str_c(stringr::str_trim(mpop_ex_2020_row1$rndrng_npi, "both"), "")

# Address
mpop_ex_address <- stringr::str_c(
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_st1, "both"), " ",
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_city, "both"), ", ",
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_state_abrvtn, "both"), " ",
  stringr::str_trim(mpop_ex_2020_row1$rndrng_prvdr_zip5, "both"))



gt_table <- mpop_13_20 |>
  dplyr::select(year,
                hcpcs     = hcpcs_cd,
                benefits  = tot_benes,
                services  = tot_srvcs,
                avg_bill  = avg_sbmtd_chrg,
                avg_allow = avg_mdcr_alowd_amt,
                avg_pay   = avg_mdcr_pymt_amt) |> 
  dplyr::group_by(hcpcs) |> 
  dplyr::summarize(
    ben_sum    = sum(benefits),
    ben_mean   = mean(benefits),
    ben_spark  = list(benefits),
    serv_sum   = sum(services),
    serv_mean  = mean(services),
    serv_spark = list(services),
    char_sum   = sum(avg_bill),
    char_mean  = mean(avg_bill),
    char_spark = list(avg_bill),
    all_sum    = sum(avg_allow),
    all_mean   = mean(avg_allow),
    all_spark  = list(avg_allow),
    pay_sum    = sum(avg_pay),
    pay_mean   = mean(avg_pay),
    pay_spark  = list(avg_pay),
    .groups = "drop") |> 
  dplyr::filter(ben_sum > 22) |> 
  dplyr::arrange(desc(ben_sum))


gt_output <- gt_table |> 
  gt::gt() |> 
  gt::tab_header(
  title = gt::md(paste0(mpop_ex_name_cred, "**Medicare Data Report**: 2013 - 2020.")), 
  subtitle = gt::md(
  "NPI: 1760485387. HCPCS Codes with a beneficiary count *less than 30* have been excluded.")) |> 
  gtExtras::gt_theme_538() |> 
  gt::tab_options(footnotes.multiline = TRUE, 
                  table.font.size = "16px",
                  heading.title.font.size = "22px") |> 
  gtExtras::gt_plt_sparkline(ben_spark, 
                             type = "ref_iqr", 
                             fig_dim = c(5, 30), 
                             same_limit = FALSE, 
                             label = FALSE,
                             palette = c("black", 
                                         "black", 
                                         "blue", 
                                         "green", 
                                         "blue")) |> 
  gtExtras::gt_plt_sparkline(serv_spark, 
                             type = "ref_iqr", 
                             fig_dim = c(5, 30), 
                             same_limit = FALSE, 
                             label = FALSE,
                             palette = c("black", 
                                         "black", 
                                         "blue", 
                                         "green", 
                                         "blue")) |> 
  gtExtras::gt_plt_sparkline(char_spark, 
                             type = "ref_iqr", 
                             fig_dim = c(5, 30), 
                             same_limit = FALSE, 
                             label = FALSE,
                             palette = c("black", 
                                         "black", 
                                         "blue", 
                                         "green", 
                                         "orange")) |> 
  gtExtras::gt_plt_sparkline(all_spark, 
                             type = "ref_iqr", 
                             fig_dim = c(5, 30), 
                             same_limit = FALSE, 
                             label = FALSE,
                             palette = c("black", 
                                         "black", 
                                         "blue", 
                                         "green", 
                                         "orange")) |> 
  gtExtras::gt_plt_sparkline(pay_spark, 
                             type = "ref_iqr", 
                             fig_dim = c(5, 30), 
                             same_limit = FALSE, 
                             label = FALSE,
                             palette = c("black", 
                                         "black", 
                                         "blue", 
                                         "green", 
                                         "orange")) |> 
  gtExtras::gt_add_divider(columns = "hcpcs", 
                           style = "solid", 
                           include_labels = FALSE,
                           weight = gt::px(3),
                           color = "gray") |>
  gt::fmt_number(columns = c(ben_sum:ben_mean, 
                             serv_sum:serv_mean), 
                             decimals = 0) |> 
  gt::fmt_currency(columns = c(char_sum:char_mean, 
                               all_sum:all_mean, 
                               pay_sum:pay_mean), 
                               currency = "USD") |> 
  gt::tab_spanner(label = "Beneficiaries", 
                  id = "ben", 
                  columns = c(ben_sum, 
                              ben_mean, 
                              ben_spark)) |> 
  gt::tab_spanner(label = "Services", 
                  id = "serv", 
                  columns = c(serv_sum, 
                              serv_mean, 
                              serv_spark)) |> 
  gt::tab_spanner(label = "Submitted Charge", 
                  columns = c(char_sum,
                              char_mean, 
                              char_spark)) |> 
  gt::tab_spanner(label = "Allowed Amount", 
                  columns = c(all_sum,
                              all_mean, 
                              all_spark)) |> 
  gt::tab_spanner(label = "Payment", 
                  columns = c(pay_sum,
                              pay_mean, 
                              pay_spark)) |> 
  gt::cols_label(ben_sum = "Count", 
                 ben_mean = "Average", 
                 ben_spark = "Trend") |> 
  gt::cols_label(serv_sum = "Count", 
                 serv_mean = "Average", 
                 serv_spark = "Trend") |> 
  gt::cols_label(char_sum = "Sum",
                 char_mean = "Average", 
                 char_spark = "Trend") |> 
  gt::cols_label(all_sum = "Sum",
                 all_mean = "Average", 
                 all_spark = "Trend") |> 
  gt::cols_label(pay_sum = "Sum", 
                 pay_mean = "Average", 
                 pay_spark = "Trend") |> 
  gt::tab_source_note(
    source_note = gt::md("Data Source: **Medicare** Physician & Other Practitioners by Provider and Service, 2013 - 2020.")) |> 
  gt::tab_footnote(
    footnote = gt::md("Number of *distinct* Medicare beneficiaries receiving the service for each HCPCS code."), 
    locations = gt::cells_column_spanners(spanners = "ben")) |> 
  gt::tab_footnote(
    footnote = gt::md("Number of services provided. *Note: The metrics used to count the number provided can vary from service to service.*"),
    locations = gt::cells_column_spanners(spanners = "serv")) |> 
  gtExtras::gt_color_rows(columns = ben_sum, 
                          palette = "RColorBrewer::Blues", pal_type = "continuous", domain = range(gt_table$ben_sum)) |> 
  gtExtras::gt_color_rows(columns = ben_mean, 
                          palette = "RColorBrewer::Blues", pal_type = "continuous", domain = range(gt_table$ben_mean)) |> 
  gtExtras::gt_color_rows(columns = serv_sum, 
                          palette = "RColorBrewer::Blues", pal_type = "continuous", domain = range(gt_table$serv_sum)) |> 
  gtExtras::gt_color_rows(columns = serv_mean, 
                          palette = "RColorBrewer::Blues", pal_type = "continuous", domain = range(gt_table$serv_mean)) |> 
  gtExtras::gt_color_rows(columns = char_sum, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$char_sum)) |> 
  gtExtras::gt_color_rows(columns = char_mean, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$char_mean)) |> 
  gtExtras::gt_color_rows(columns = all_sum, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$all_sum)) |> 
  gtExtras::gt_color_rows(columns = all_mean, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$all_mean)) |> 
  gtExtras::gt_color_rows(columns = pay_sum, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$pay_sum)) |> 
  gtExtras::gt_color_rows(columns = pay_mean, 
                          palette = "RColorBrewer::Oranges", pal_type = "continuous", domain = range(gt_table$pay_mean)) |> 
  gt::opt_vertical_padding(scale = 1.5)

#gt::gtsave(gt_output, filename = "gt_provider3.png", expand = 20, zoom = 2, vwidth = 1500)
```

</details>

<br>
<br>
