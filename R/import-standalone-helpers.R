# Standalone file: do not edit by hand
# Source: https://github.com/andrewallenbruce/fuimus/blob/HEAD/R/standalone-helpers.R
# Generated by: usethis::use_standalone("andrewallenbruce/fuimus", "helpers")
# ----------------------------------------------------------------------
#
# ---
# repo: andrewallenbruce/fuimus
# file: standalone-helpers.R
# last-updated: 2024-12-13
# license: https://unlicense.org
# imports: [cheapr (>= 0.9.92), collapse (>= 2.0.18), kit (>= 0.0.19), stringfish (>= 0.16.0), stringi (>= 1.8.4), vctrs (>= 0.6.5)]
# ---
#
# ## Changelog
#
# 2024-12-13:
#
# * Added sf_replace()
#
# 2024-12-12:
#
# * Fixed bug in search_in()
# * Shortened as_() names
# * Added roundup()
#
# 2024-12-11:
#
# * Renamed null_if_empty() to if_empty_null()
#
# * Added:
#    * invert_named()
#    * true()
#    * false()
#    * as_character()
#    * as_integer()
#    * as_numeric()
#    * as_date()
#
# 2024-12-10:
#
# * Initial version.
#
# nocov start

# vctrs -------------------------------------------------------------------
#
#' Is Vector Empty?
#'
#' @param x vector
#'
#' @noRd
empty <- \(x) { vctrs::vec_is_empty(x) }

#' If `x` is empty, `NULL`, else `x`
#'
#' @param x vector
#'
#' @noRd
if_empty_null <- \(x) { if (empty(x)) NULL else x }

#' Search in data frame
#'
#' @param x vector or `<data.frame>`
#'
#' @param column `<chr>` string of column name
#'
#' @param what to search for in `column`
#'
#' @noRd
search_in_impl <- \(x, column, what) {
  vctrs::vec_slice(
    x,
    vctrs::vec_in(
      x[[column]],
      uniq(what)))
}

#' Search in data frame column if search term is not `NULL`
#'
#' @param x vector or `<data.frame>`
#'
#' @param column `<chr>` string of column name
#'
#' @param what to search for in `column`
#'
#' @noRd
search_in <- \(x, column, what) {

  if (null(what)) return(x)

  search_in_impl(x, column, what)
}

# kit ---------------------------------------------------------------------
#
#' ifelse wrapper using kit::iif
#'
#' @param x `<lgl>` vector
#'
#' @param yes,no Values to return depending on TRUE/FALSE element of `x`. Must
#'   be same type and be either length 1 or same length of `x`.
#'
#' @noRd
iif_else <- \(x, yes, no) { kit::iif(test = x, yes = yes, no = no, nThread = 4L) }

#' Parallel Sort
#'
#' @param x `<chr>` vector. If other, will default to [base::sort()]
#'
#' @noRd
strsort <- \(x) { kit::psort(x, nThread = 4L) }

# cheapr -------------------------------------------------------------------
#
#' Predicate to filter out NAs
#'
#' @param x vector
#'
#' @noRd
na <- \(x) { cheapr::is_na(x) }

#' Predicate to filter out NAs
#'
#' @param x vector
#'
#' @noRd
not_na <- \(x) { !na(x) }

# collapse -----------------------------------------------------------------
#
#' Get named element from list
#'
#' @param l named `<list>`
#'
#' @param e `<chr>` element name; can be a regex pattern
#'
#' @noRd
getelem <- \(l, e) { collapse::get_elem(l = l, elem = e, regex = TRUE) }

#' Lengths of Vector
#'
#' @param x vector
#'
#' @noRd
vlen <- \(x) { collapse::vlengths(x, use.names = FALSE) }

#' Unique Values of Vector
#'
#' @param x vector
#'
#' @noRd
uniq <- \(x) { collapse::funique(x) }

#' Unique Lengths of Vector
#'
#' @param x vector
#'
#' @noRd
uniq_vlen <- \(x) { uniq(vlen(x)) }

#' Unique Values with NAs Removed
#'
#' @param x vector
#'
#' @noRd
uniq_narm <- \(x) { uniq(collapse::na_rm(x)) }

#' Maximum Vector Length
#'
#' @param x vector
#'
#' @noRd
max_vlen <- \(x) { collapse::fmax(vlen(x)) }

# stringfish ---------------------------------------------------------------
#
#' Subset Vector by Range
#'
#' @param x `<chr>` vector
#'
#' @param start `<int>` index start; default is `1`
#'
#' @param stop `<int>` index end
#'
#' @noRd
sf_sub <- \(x, start = 1, stop) { stringfish::sf_substr(x, start = start, stop = stop, nthreads = 4L) }

#' Convert string to stringfish vector
#'
#' @param x `<chr>` vector
#'
#' @noRd
sf_conv <- \(x) { stringfish::convert_to_sf(x) }

#' Count number of characters in character vector
#'
#' @param x `<chr>` vector
#'
#' @noRd
sf_chars <- \(x) { stringfish::sf_nchar(x, nthreads = 4L) }

#' Subset Vector at One Index Point
#'
#' @param x `<chr>` vector
#'
#' @param idx `<int>` index
#'
#' @noRd
sf_at <- \(x, idx = 1) { sf_sub(x, start = idx, stop = idx) }

#' Detect by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @noRd
sf_detect <- \(s, p) { stringfish::sf_grepl(s, p, nthreads = 4L) }

#' Detect Opposite by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @noRd
sf_ndetect <- \(s, p) { !stringfish::sf_grepl(s, p, nthreads = 4L) }

#' Extract by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @noRd
sf_extract <- \(s, p) { s[sf_detect(s, p)] }

#' Extract Opposite by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @noRd
sf_nextract <- \(s, p) { s[sf_ndetect(s, p)] }

#' Replace by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @param r `<chr>` replacement
#'
#' @param fix `<lgl>` fixed or regex; default is `FALSE`
#'
#' @noRd
sf_replace <- \(s, p, r, fix = FALSE) { stringfish::sf_gsub(subject = s, pattern = p, replacement = r, fixed = fix, nthreads = 4L) }

#' Remove by Regex
#'
#' @param s `<chr>` vector
#'
#' @param p `<chr>` regex pattern
#'
#' @param fix `<lgl>` fixed or regex; default is `FALSE`
#'
#' @noRd
sf_remove <- \(s, p, fix = FALSE) { stringfish::sf_gsub(subject = s, pattern = p, replacement = "", fixed = fix, nthreads = 4L) }

#' Remove single or double quotes from a character string
#'
#' @param x `<chr>` vector to convert
#'
#' @noRd
remove_quotes <- \(x) { sf_remove(x, '["\']') }

#' Concatenate Vectors
#'
#' @param ... Any number of vectors, coerced to `<chr>` vector, if necessary
#'
#' @noRd
sf_c <- \(...) { stringfish::sfc(...) }

#' Collapse Vector
#'
#' @param x `<chr>` vector
#'
#' @param sep `<chr>` separator; default is `""`
#'
#' @noRd
sf_smush <- \(x, sep = "") { stringfish::sf_collapse(x, collapse = sep) }

#' Split string by delimiter
#'
#' @param x `<chr>` vector
#'
#' @param s `<chr>` delimiter to split by
#'
#' @param fix `<lgl>` fixed or regex; default is `TRUE`
#'
#' @noRd
sf_strsplit <- \(x, s, fix = TRUE) { stringfish::sf_split(subject = x, split = s, fixed = fix, nthreads = 4L) }

# stringi -----------------------------------------------------------------
#
#' Generate random strings
#'
#' @param n `<int>` number of strings to generate
#'
#' @param ln `<int>` length of each string
#'
#' @param p `<chr>` pattern to sample from; default is `"[A-Z0-9]"`
#'
#' @noRd
random_string <- \(n, ln, p = "[A-Z0-9]") { stringi::stri_rand_strings(n = n, length = ln, pattern = p) }

# base --------------------------------------------------------------------
#
#' Unlist and unname
#'
#' @param x Named or unnamed `<list>`
#'
#' @returns Unnamed `<chr>` vector
#'
#' @noRd
delist <- \(x) { unlist(x, use.names = FALSE) }

#' Unlist, unname and split
#'
#' @param x `<chr>` string or named `<list>`
#'
#' @noRd
desplit <- \(x) {

  res <- sf_strsplit(delist(x), "")

  if (length(res) == 1) return(res[[1]])

  res
}

#' Is `x` `NULL`?
#'
#' @param x input
#'
#' @returns `<lgl>` `TRUE` if `x` is `NULL`, else `FALSE`
#'
#' @noRd
null <- \(x) { is.null(x) }

#' Is `x` not `NULL`?
#'
#' @param x input
#'
#' @returns `<lgl>` `TRUE` if `x` is not `NULL`, else `FALSE`
#'
#' @noRd
not_null <- \(x) { !null(x) }

#' Is `x` `TRUE`?
#'
#' @param x input
#'
#' @returns `<lgl>` `TRUE` if `x` is `TRUE`, else `FALSE`
#'
#' @noRd
true <- \(x) { isTRUE(x) }

#' Is `x` `FALSE`?
#'
#' @param x input
#'
#' @returns `<lgl>` `TRUE` if `x` is `FALSE`, else `FALSE`
#'
#' @noRd
false <- \(x) { isFALSE(x) }

#' Coerce vector to `<chr>`
#'
#' @param x vector
#'
#' @returns `<chr>` vector
#'
#' @autoglobal
#'
#' @noRd
as_chr <- \(x) { if (is.character(x)) x else as.character(x) }

#' Coerce vector to `<int>`
#'
#' @param x vector
#'
#' @returns `<int>` vector
#'
#' @autoglobal
#'
#' @noRd
as_int <- \(x) { if (is.integer(x)) x else as.integer(x) }

#' Coerce vector to `<num>` class
#'
#' @param x vector
#'
#' @returns `<num>` vector
#'
#' @autoglobal
#'
#' @noRd
as_num <- \(x) { if (is.numeric(x)) x else as.numeric(x) }

#' Coerce vector to `<date>` class
#'
#' @param x vector
#'
#' @param ... additional arguments
#'
#' @param fmt `<chr>` format; default is `"%Y-%m-%d"`
#'
#' @returns `<date>` vector
#'
#' @autoglobal
#'
#' @noRd
as_date <- \(x, ..., fmt = "%Y-%m-%d") { as.Date(x, ..., format = fmt) }

#' Invert a named vector
#'
#' @param x A named vector
#'
#' @returns A named vector with names and values inverted
#'
#' @autoglobal
#'
#' @noRd
invert_named <- \(x) {
  stopifnot("Input must be a named vector" = not_null(names(x)))
  stats::setNames(names(x), unname(x))
}

#' Round up to nearest decimal place
#'
#' @param x `<num>` vector
#'
#' @param d `<int>` decimal places to round to; default is `2`
#'
#' @returns `<num>` vector rounded up to the nearest decimal place
#'
#' @autoglobal
#'
#' @noRd
roundup <- \(x, d = 2) {

  d  <- 10^d

  z  <- abs(x) * d

  z  <- z + 0.5 + sqrt(.Machine[["double.eps"]])

  z  <- trunc(z)

  z  <- z / d

  z * sign(x)
}
# nocov end
